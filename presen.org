#+title: 
#+author: Masataro Asai
#+include: "head.org"
#+LINK: img file:img/%s
#+LINK: png file:img/%s.png
#+LINK: jpg file:img/%s.jpg
#+LINK: spng file:img/static/%s.png
#+LINK: sjpg file:img/static/%s.jpg

#+html_head: <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:500,900">
#+html_head_extra:

#+begin_outline-text-1

#+begin_center
#+begin_larger
*Beyond Common Lisp*
+    ...? 
#+end_larger

+ ok, sorry, I was a little clickbaity


#+end_center

#+begin_note
#+begin_alignright
Made by guicho2.71828 (Masataro Asai)
#+end_alignright
#+end_note
#+end_outline-text-1

# honestly I was just thinking about 
# the 

* Me

+ Ph.D in Automated Planning / Heuristic Graph Search (aka symbolic AI) (U. Tokyo)
+ Creating the future AI with Neural-Symbolic hybrid at IBM
+ A somewhat competent Common Lisper

[[spng:ranking]]

* About this informal short talk

+ Wish to talk about the current limit of the language
  + *without sounding ignorant*
  + macro system
    + no, not about hygenic macros
  + package system
  + type system
  + misc.
+ propose some language prototypes
  + the ideas are thought out few months ago
+ 

* Part 1 : "Lisp macros are awesome!"

+ It is.
+ but once you stay in common lisp for many years, it feels something is missing

** The case of local macros in Iterate

 + Iterate: the lispier alternative to loop
 + Has various *local macros*
   #+begin_src lisp
 (iter (for i below 5)   ; <- local macro
       (for j = (1+ i))  ; <- local macro
       (print i))
   #+end_src
 + They cannot be implemented by =macrolet/defmacro=
   + because the =iterate= macro *must detect =for= beforehand*

** Iterate as =macrolet= ?

 A simplified version that supports only =for=

 #+begin_src lisp
 (iter (for i below 5)
       (for j = (1+ i))
       (print j))
 #+end_src

 What =iterate= must do for =for=:

 + Detect the variables, its initialization, stepping, stopping criteria

 #+begin_src lisp
 (defmacro iter (&body body)
   `(macrolet ((for (...) ...))
      ,@body))
 #+end_src

 + *Useless:* =for= in =body= are expanded *after* expanding =iter=
 + We need *inter-macro communications*

** Current solution: Code walker

 Iterate walks across the code body

 + Standard macros are expanded (exposing the local macro inside)

 #+begin_src lisp
 (defmacro for2 (&rest args) `(for ,@args))

 (iter (for2 i below 5)
       (print i))        ; works
 #+end_src

 + Surrounding =macrolet='s are also expanded

 #+begin_src lisp
 (macrolet ((for2 (&rest args) `(for ,@args)))
   (iter (for2 i below 5)
         (print i)))        ; works
 #+end_src

 This can be done by passing =&environment= variable to =macroexpand=.

** However, inner =macrolet='s cause problems

 #+begin_src lisp
 (iter (for i below 5)
       (macrolet ((collect (x) `(print ,x)))
         (collect i)))

 WARNING: Iterate:
 Iterate does not know how to handle the special form (MACROLET ...)

   The function ITERATE:COLLECT is undefined.
      [Condition of type UNDEFINED-FUNCTION]
 #+end_src

 *This cannot be done in ANSI CL*
 + Requires CLtL2 =augment-environement= to shadow the outer binding
 + =iterate= does not use it -- it has its own walker.

** Sketch                                                          :noexport:

 #+begin_src lisp
 (defun walk (form env)
   (let ((form (macroexpand form env)))
     (case (car form)
       ('tagbody ...)
       ...
       ('macrolet
        (destructuring-bind (bindings . body) (rest form)
          (walk `(progn ,@body) (sb-cltl2:augment-environment env :macro binding))))
       ...)))

 (defmacro for (&rest args)
   (cerror 'for-found :args args)
   '(progn))

 (defmacro iter (&body body &environment e)
   (let (metadata)
     (handler-bind ((for-found
                      (lambda (c)
                         (push-metadata c metadata) ; (1)
                         (continue c))))
        (let ((body (walk `(progn ,@body) e)))
          (wrap metadata body)))))                  ; (2)
 #+end_src

** But writing a code walker is dumb

 + Every inter-macro communication requires *its own code walker*
 + hu.dwim.walker is not a solution (returns a CLOS object tree)
 + *Can be replaced by* =macroexpand-all=

** MACROEXPAND-ALL Sketch

 #+begin_src lisp
 (ql:quickload :trivial-macroexpand-all)
 (use-package :trivial-macroexpand-all)

 (defmacro for (&rest args)
   (cerror "ignore" 'for-found :args args)
   '(progn))

 (defmacro iter (&body body &environment e)
   (let (metadata)
     (handler-bind ((for-found
                      (lambda (c)
                         (push c metadata)          ; (1)
                         (continue c))))
        (let ((body (macroexpand-all `(progn ,@body) e)))
          (wrap metadata body)))))                  ; (2)
 #+end_src

** Lisp macros are strictly normal order

 #+begin_container-fluid
 #+begin_row-fluid
 #+begin_span6
 #+begin_src lisp
 (when x
   (when y
     ...body...))

 (if x
     (when y
       ...body...)
     nil)

 (if x
     (if y
         ...body...
         nil)
     nil)
 #+end_src
 #+end_span6
 #+begin_span6
 + this limits the ability to write a /local macro/.
 #+end_span6
 #+end_row-fluid
 #+end_container-fluid

** Normal order evaluation vs Applicative order evaluation         :noexport:

 #+begin_src lisp
 ;; Assume + and * are primitives (normal form)
 (defun 1+     (x) (+ 1 x))
 (defun square (x) (* x x))
 #+end_src

 #+begin_container-fluid
 #+begin_row-fluid
 #+begin_span6
 Applicable order evaluation:

 + =(square (1+ 5))=
 + =(* (1+ 5) (1+ 5))= --> needs values for =(1+ 5)=
 + =(* (+ 1 5) (1+ 5))=
 + =(* (+ 1 5) (+ 1 5))=

 #+end_span6
 #+begin_span6
 #+end_span6
 #+end_row-fluid
 #+end_container-fluid

** Local macro and macrolet                                        :noexport:

* Part 2: package system and symbols

+ notorious
+ 
